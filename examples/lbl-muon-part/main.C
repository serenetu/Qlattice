#include <qlat/qlat.h>

#include <iostream>

const char* cname = "Main";

void setField(qlat::Field<qlat::Complex>& f)
{
  TIMER("setField");
  const qlat::Geometry& geo = f.geo;
#pragma omp parallel for
  for (long index = 0; index < geo.localVolume(); ++index) {
    qlat::Coordinate x; geo.coordinateFromIndex(x, index);
    qlat::Vector<qlat::Complex> fx = f.getElems(x);
    for (int m = 0; m < geo.multiplicity; ++m) {
      fx[m] = geo.geon.idNode * sqrt(2) + index * sqrt(3) * qlat::ii + m * sqrt(5);
    }
  }
}

qlat::SpinMatrix projPositiveState(const qlat::SpinMatrix& x)
{
  const qlat::SpinMatrix psm = (qlat::SpinMatrixConstants::getUnit() + qlat::SpinMatrixConstants::getGamma(3)) / 2.0;
  return psm * x * psm;
}

qlat::SpinMatrix lblMuonLine(const int tsnk, const int tsrc,
    const qlat::QedGaugeField& egf1, const qlat::QedGaugeField& egf2, const qlat::QedGaugeField& egf3,
    const double mass, const std::array<double,qlat::DIM>& momtwist)
{
  TIMER("lblMuonLine");
  const qlat::Geometry& geo = egf1.geo;
  qlat::SpinPropagator4d sol; sol.init(geo);
  qlat::SpinPropagator4d src; src.init(geo);
  qlat::setZero(src);
  qlat::setWallSourcePlusM(src, 1.0, tsrc);
  qlat::propSpinPropagator4d(src, mass, momtwist);
  //
  sol = src;
  qlat::setZero(src);
  qlat::sequentialPhotonSpinPropagatorPlusM(src, qlat::ii, egf1, sol);
  qlat::propSpinPropagator4d(src, mass, momtwist);
  //
  sol = src;
  qlat::setZero(src);
  qlat::sequentialPhotonSpinPropagatorPlusM(src, qlat::ii, egf2, sol);
  qlat::propSpinPropagator4d(src, mass, momtwist);
  //
  sol = src;
  qlat::setZero(src);
  qlat::sequentialPhotonSpinPropagatorPlusM(src, qlat::ii, egf3, sol);
  qlat::propSpinPropagator4d(src, mass, momtwist);
  //
  qlat::SpinPropagator4d snk; snk.init(geo);
  qlat::setZero(snk);
  qlat::setWallSourcePlusM(snk, 1.0, tsnk);
  return qlat::contractSpinPropagator4d(snk, src);
}

qlat::SpinMatrix lblMuonLineC(const int tsnk, const int tsrc,
    const qlat::QedGaugeField& egf1, const qlat::QedGaugeField& egf2, const qlat::QedGaugeField& egf3,
    const double mass, const std::array<double,qlat::DIM>& momtwist)
{
  TIMER("lblMuonLineC");
  qlat::SpinMatrix sm; qlat::setZero(sm);
  sm += lblMuonLine(tsnk, tsrc, egf1, egf2, egf3, mass, momtwist);
  sm += lblMuonLine(tsnk, tsrc, egf2, egf3, egf1, mass, momtwist);
  sm += lblMuonLine(tsnk, tsrc, egf3, egf1, egf2, mass, momtwist);
  sm += lblMuonLine(tsnk, tsrc, egf3, egf2, egf1, mass, momtwist);
  sm += lblMuonLine(tsnk, tsrc, egf2, egf1, egf3, mass, momtwist);
  sm += lblMuonLine(tsnk, tsrc, egf1, egf3, egf2, mass, momtwist);
  return sm;
}

qlat::SpinMatrix lblMuonPartPointSrc(const qlat::Geometry& geo, const int tsnk, const int tsrc,
    const qlat::Coordinate& xg1, const int mu1,
    const qlat::Coordinate& xg2, const int mu2,
    const qlat::Coordinate& xg3, const int mu3,
    const double mass, const std::array<double,qlat::DIM>& momtwist)
{
  TIMER("lblMuonPartPointSrc");
  qlat::QedGaugeField egf1; egf1.init(geo);
  qlat::QedGaugeField egf2; egf2.init(geo);
  qlat::QedGaugeField egf3; egf3.init(geo);
  qlat::setZero(egf1);
  qlat::setZero(egf2);
  qlat::setZero(egf3);
  qlat::setPointSourcePlusM(egf1, 1.0, xg1, mu1);
  qlat::setPointSourcePlusM(egf2, 1.0, xg2, mu2);
  qlat::setPointSourcePlusM(egf3, 1.0, xg3, mu3);
  // ADJUST ME
  qlat::propPhotonInvert(egf1, momtwist);
  qlat::propPhotonInvert(egf2, momtwist);
  qlat::propPhotonInvert(egf3, momtwist);
  // ADJUST ME
  return lblMuonLine(tsnk, tsrc, egf1, egf2, egf3, mass, momtwist);
  // return lblMuonLineC(tsnk, tsrc, egf1, egf2, egf3, mass, momtwist);
}

void lblMagneticMomentSpinMatrix(qlat::Array<qlat::SpinMatrix,3> bs, const qlat::Geometry& geo, const int tsnk, const int tsrc,
    const double mass, const std::array<double,qlat::DIM>& momtwist)
  // pretend to the operator to be
  // \Sigma_i * mass / 2
{
  TIMER("lblMagneticMomentSpinMatrix");
  qlat::SpinPropagator4d snk; snk.init(geo);
  qlat::SpinPropagator4d src; src.init(geo);
  qlat::setZero(snk);
  qlat::setZero(src);
  qlat::setWallSourcePlusM(snk, 1.0, tsnk);
  qlat::setWallSourcePlusM(src, 1.0, tsrc);
  qlat::propSpinPropagator4d(snk, mass, momtwist);
  qlat::propSpinPropagator4d(src, mass, momtwist);
  const int top = qlat::mod(tsrc + qlat::mod(tsnk - tsrc, geo.totalSite(3)) / 2, geo.totalSite(3));
  qlat::Coordinate xgop(0, 0, 0, top);
  qlat::Coordinate xlop; geo.coordinateLfG(xlop, xgop);
  qlat::setZero(bs);
  if (geo.isLocal(xlop)) {
    Display(cname, fname, "src =\n%s\n", qlat::show(src.getElem(xlop)).c_str());
    Display(cname, fname, "snk =\n%s\n", qlat::show(snk.getElem(xlop)).c_str());
    for (int i = 0; i < 3; ++i) {
      bs[i] = qlat::SpinMatrixConstants::getGamma5() * snk.getElem(xlop).adjoint() * qlat::SpinMatrixConstants::getGamma5();
      bs[i] *= qlat::SpinMatrixConstants::getCapSigma(i) * mass / 2.0;
      bs[i] *= src.getElem(xlop);
      bs[i] = projPositiveState(bs[i]);
    }
  }
  qlat::sumVector(qlat::Vector<double>((double*)bs.data(), getDataSize(bs)/sizeof(double)));
}

qlat::Complex linearFit(const qlat::SpinMatrix& x, const qlat::SpinMatrix& base)
{
  return (Eigen::conj(base.array()) * x.array()).sum() / (Eigen::conj(base.array()) * base.array()).sum();
}

void lblShowMuonPartPointSrc(const qlat::Geometry& geo, const int tsnk, const int tsrc,
    const qlat::Array<qlat::SpinMatrix,3>& bs,
    const qlat::Coordinate& xg1, const int mu1,
    const qlat::Coordinate& xg2, const int mu2,
    const qlat::Coordinate& xg3, const int mu3,
    const double mass, const std::array<double,qlat::DIM>& momtwist)
{
  TIMER("lblShowMuonPartPointSrc");
  DisplayInfo(cname, fname, "mass = %.2f\n", mass);
  DisplayInfo(cname, fname, "xg1 = %s ; xg2 = %s ; xg3 = %s .\n",
      qlat::show(xg1).c_str(), qlat::show(xg2).c_str(), qlat::show(xg3).c_str());
  DisplayInfo(cname, fname, "mu1 = %d ; mu2 = %d ; mu3 = %d .\n", mu1, mu2, mu3);
  qlat::SpinMatrix muonline = lblMuonPartPointSrc(geo, tsnk, tsrc, xg1, mu1, xg2, mu2, xg3, mu3, mass, momtwist);
  muonline = projPositiveState(muonline);
  DisplayInfo(cname, fname, "norm(muonline) = %.16e\n", qlat::norm(muonline));
  if (qlat::norm(muonline) < 1.0e-30) {
    return;
  }
  DisplayInfo(cname, fname, "muonline =\n%s\n", qlat::show(muonline).c_str());
  DisplayInfo(cname, fname, "linearFit[0] = %s\n", qlat::show(linearFit(muonline,bs[0])).c_str());
  DisplayInfo(cname, fname, "linearFit[1] = %s\n", qlat::show(linearFit(muonline,bs[1])).c_str());
  DisplayInfo(cname, fname, "linearFit[2] = %s\n", qlat::show(linearFit(muonline,bs[2])).c_str());
  DisplayInfo(cname, fname, "linearFitUni = %s\n",
      qlat::show(linearFit(muonline,projPositiveState(qlat::SpinMatrixConstants::getUnit()))).c_str());
  DisplayInfo(cname, fname, "linearFit[0] * 1e9 = %10.2f\n", 1e9*linearFit(muonline,bs[0]).real());
  DisplayInfo(cname, fname, "linearFit[1] * 1e9 = %10.2f\n", 1e9*linearFit(muonline,bs[1]).real());
  DisplayInfo(cname, fname, "linearFit[2] * 1e9 = %10.2f\n", 1e9*linearFit(muonline,bs[2]).real());
}

void lblMuonPart()
{
  TIMER("lblMuonPart");
  // ADJUST ME
  qlat::Coordinate totalSite(16, 16, 16, 32);
  // qlat::Coordinate totalSite(32, 32, 32, 128);
  qlat::Geometry geo; geo.init(totalSite, 1);
  DisplayInfo(cname, fname, "geo =\n%s\n", qlat::show(geo).c_str());
  std::array<double,qlat::DIM> momtwist;
  momtwist[0] = 0.0;
  momtwist[1] = 0.0;
  momtwist[2] = 0.0;
  momtwist[3] = 0.0;
  const double mass = 0.05;
  const int tsnk = geo.totalSite(3)/4*3;
  const int tsrc = geo.totalSite(3)/4;
  std::array<qlat::SpinMatrix,3> bs;
  lblMagneticMomentSpinMatrix(bs, geo, tsnk, tsrc, mass, momtwist);
  DisplayInfo(cname, fname, "bs[0] =\n%s\n", qlat::show(bs[0]).c_str());
  DisplayInfo(cname, fname, "bs[1] =\n%s\n", qlat::show(bs[1]).c_str());
  DisplayInfo(cname, fname, "bs[2] =\n%s\n", qlat::show(bs[2]).c_str());
  // ADJUST ME
  // qlat::Coordinate xg1(0, 0, 0, geo.totalSite(3)/2 + 0);
  // qlat::Coordinate xg2(0, 0, 0, geo.totalSite(3)/2 + 0);
  // qlat::Coordinate xg3(0, 0, 0, geo.totalSite(3)/2 + 0);
  //
  qlat::Coordinate xg1(2, 2, 2, geo.totalSite(3)/2 + 2);
  qlat::Coordinate xg2(0, 0, 0, geo.totalSite(3)/2 + 0);
  qlat::Coordinate xg3(0, 0, 0, geo.totalSite(3)/2 + 0);
  //
  // qlat::Coordinate xg1(2, 1, 5, geo.totalSite(3)/2 - 4);
  // qlat::Coordinate xg2(3, 4, 0, geo.totalSite(3)/2 + 0);
  // qlat::Coordinate xg3(1, 5, 2, geo.totalSite(3)/2 + 4);
  //
  for (int mu1 = 0; mu1 < 4; ++mu1) {
    for (int mu2 = 0; mu2 < 4; ++mu2) {
      for (int mu3 = 0; mu3 < 4; ++mu3) {
        lblShowMuonPartPointSrc(geo, tsnk, tsrc, bs, xg1, mu1, xg2, mu2, xg3, mu3, mass, momtwist);
        Timer::display();
        return;
      }
    }
  }
}

void displayGammas()
{
  TIMER("displayGammas");
  DisplayInfo(cname, fname, "gamma5 =\n%s\n", qlat::show(qlat::SpinMatrixConstants::getGamma5()).c_str());
  DisplayInfo(cname, fname, "gamma0 * gamma1 * gamma2 * gamma3 =\n%s\n",
      qlat::show(
        qlat::SpinMatrixConstants::getGamma(0) *
        qlat::SpinMatrixConstants::getGamma(1) *
        qlat::SpinMatrixConstants::getGamma(2) *
        qlat::SpinMatrixConstants::getGamma(3)
        ).c_str());
  DisplayInfo(cname, fname, "gamma3 =\n%s\n", qlat::show(qlat::SpinMatrixConstants::getGamma(3)).c_str());
  DisplayInfo(cname, fname, "ii * gamma0 =\n%s\n", qlat::show(qlat::ii * qlat::SpinMatrixConstants::getGamma(0)).c_str());
  DisplayInfo(cname, fname, "ii * gamma1 =\n%s\n", qlat::show(qlat::ii * qlat::SpinMatrixConstants::getGamma(1)).c_str());
  DisplayInfo(cname, fname, "ii * gamma2 =\n%s\n", qlat::show(qlat::ii * qlat::SpinMatrixConstants::getGamma(2)).c_str());
}

void displaySpinPropagator4d()
{
  TIMER("displaySpinPropagator4d");
  qlat::Coordinate totalSite(16, 16, 16, 32);
  qlat::Geometry geo; geo.init(totalSite, 1);
  DisplayInfo(cname, fname, "geo =\n%s\n", qlat::show(geo).c_str());
  std::array<double,qlat::DIM> momtwist;
  momtwist[0] = 0.0;
  momtwist[1] = 0.0;
  momtwist[2] = 0.0;
  momtwist[3] = 0.0;
  const double mass = 0.1;
  qlat::SpinPropagator4d prop; prop.init(geo);
  setZero(prop);
  qlat::Coordinate xgsrc(0, 0, 0, 0);
  qlat::Coordinate xlsrc; geo.coordinateLfG(xlsrc, xgsrc);
  if (geo.isLocal(xlsrc)) {
    qlat::setUnit(prop.getElem(xlsrc));
  }
  qlat::propSpinPropagator4d(prop, mass, momtwist);
  qlat::Coordinate xgsnk(0, 0, 0, 0);
  qlat::Coordinate xlsnk; geo.coordinateLfG(xlsnk, xgsnk);
  DisplayInfo(cname, fname, "xgsnk = %s .\n", qlat::show(xgsnk).c_str());
  if (geo.isLocal(xlsnk)) {
    Display(cname, fname, "prop[xgsnk] =\n%s\n", qlat::show(prop.getElem(xlsnk)).c_str());
  }
}

int main(int argc, char* argv[])
{
  qlat::begin(&argc, &argv);
  displayGammas();
  displaySpinPropagator4d();
  Timer::display();
  lblMuonPart();
  Timer::display();
  qlat::end();
  return 0;
}
